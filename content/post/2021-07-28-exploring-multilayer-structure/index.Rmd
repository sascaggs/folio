---
title: Exploring multilayer structure
author: Shane A. Scaggs
date: '2021-07-28'
slug: []
categories:
  - Simulation
tags:
  - matrix
  - array
  - network analysis
  - generative model
  - multilayer
draft: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Dear reader, 

In this post, I explore some data structures in `R` that can be used to represent multilayer network structure. I also used this structure to build a simple generative model of a slowly growing network. 

# Part I: Matrices and Arrays 

Networks can have multiple layers representing different kinds of relationships or changing relationships over time. Each network layer can be represented as a `matrix.` 

```{r}
N <- 5
M <- matrix( rep(0, 5^2), nrow = N)
M
```

The values along the diagonal of the matrix are loops (i.e., self-ties, cannibalism, etc.). 

```{r}
diag(M) <- 1
M
diag(M) <- 0
```

And the values in the upper and lower triangles of the matrix indicate directionality in the network. 

```{r}
upper.tri(M)
lower.tri(M)
```

We can assign values `N^2` to each element in the matrix using Bernoulli trials to generate a random graph (e.g. the Erdos-Renyi model). 

```{r}
set.seed(777)
M <- matrix( rbinom(N^2, 1, 0.5), nrow = N )
M
```

Now if we want to work with multiple layers, we can generate `k` matrices and store them in an `array` with dimensions `(N,N,k)`. 

```{r}
k <- 4
l <- replicate( n = k, 
                expr = matrix( rbinom(N^2, 1, 0.5), nrow = N )
)
l
dim(l)
```

Alternatively, we can build an array directly, but this time we need `(N^2)*k` trials in order to fill every element of every matrix in the three dimensional array. 

```{r}
A <- array( rbinom((N^2)*k, 1, 0.5), dim = c(N,N,k) )
A
```

We can visualize each matrix as well.

```{r, fig.height=3, fig.width=10}
par(mfrow=c(1,k))
apply(A, MARGIN = 3, image, axes=F, col=c('black','cornflowerblue'))
```

# Part II: A generative model 

Generating random arrays is fine, but when we look at them in sequence, the just look random flickering over time. What if we wanted to construct a network that *grows* randomly based on the previous conditions? The function below accomplishes this using the following steps: 

1. Create an empty array with dimensions `(N,N,layers)` to hold results. 
2. Set an initial conditions by randomly selecting an element in the first matrix and assigning it a value of `1`. 
3. Using for loops, examine every element `[i,j]` in the current layer (`k`) and compare to the previous layer (`k-1`). 
    1. If the element is filled, remain filled. 
    2. If the element is empty, a slim chance that it gets filled. 
4. Return the complete array. 

```{r}
RandomGrowth <- function(N, layers, p, seed=777, loops=F) {
  set.seed(seed)
  
  # create an empty array to hold results
  A <- array(NA, dim = c(N,N,layers))
  
  # set initial condition by randomly selecting
  init <- matrix( rep(0, N^2), nrow = N )
  init[ sample(1:N, 1), sample(1:N, 1) ] <- 1
  A[,,1] <- init
  
  # loop through
  for( k in 2:layers ) {
    for( i in 1:N ) {
      for( j in 1:N ) {
        A[i,j,k] <- ifelse( A[i,j,k-1] > 0, 1, 
                            rbinom(1, 1, prob = p))
        if (loops == F) { diag(A[,,k]) <- 0 } 
      }
    }
  }
  return(A)
}

```

To use the function, we need to set the following: 

- `N` = the number of rows and columns in each matrix (i.e., number of nodes).
- `layers` = the third dimension of the array; the number of matrix layers. 
- `p` = the probability that an empty cell is filled; this controls the growth rate. 

```{r}
N <- 25
k <- 20
p <- 0.01
new_A <- RandomGrowth(N=N, layers=k, p=p, seed = 27, loops = T)
```

Now we can plot each matrix and see how the network grows. 

```{r, fig.width=9, fig.height=8}
par(mfrow=c(5,4), mar=c(1,1,1,1))
apply(new_A, 3, image, axes=F, col=c('black','cornflowerblue'))
```

It appears as though this network is growing in a slow, additive way. This is because the only spread that occurs is based on our random trial with probability `p`, which prevents each filled cell from invading neighboring empty cells. We can visualize the growth by plotting the density of each matrix at `k`. 

```{r}
plot(1:k, apply(new_A, 3, function(x) sum(x) / N^2), 
     ylab='density')
```

But perhaps the additive pattern we are seeing is only because we didn't let the network grow for long enough. What if we let the algorithm go longer by increasing `k`? Shouldn't the array eventually fill up completely? If so, we should expect to see a logistic growth pattern. 

```{r, fig.width=10, fig.height=7}
N <- 25
k <- 200
p <- 0.01
new_A <- RandomGrowth(N=N, layers=k, p=p, seed = 27, loops=T)

par(mfrow=c(10,20), mar=c(0.1,0.1,0.1,0.1))
apply(new_A, 3, image, axes=F, col=c('black','cornflowerblue'))
```

Now we calculate the density for every matrix in our 25 x 25 x 200 array and see if there is a logistic curve. 

```{r}
plot(1:k, apply(new_A, 3, function(x) sum(x) / N^2), 
     ylab='density')
```
There you have it. A simple generative and random model of logistic growth.

In the next post, I will explore extensions to this generative model where growth spreads across neighboring cells (e.g. cellular automata), and where nodes with the largest number of connections tend to gain more connections (e.g. preferential attachment). 

Maximum regards, 

SAS
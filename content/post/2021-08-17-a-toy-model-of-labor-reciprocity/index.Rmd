---
title: A toy model of labor exchange over time
author: Shane A. Scaggs
date: '2021-08-17'
slug: []
categories:
  - Simulation
tags:
  - anthropology
  - statnet
  - network analysis
  - generative model
  - labor exchange
  - reciprocity
  - igraph
  - tidygraph
draft: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preamble 

Humans around the globe regularly exchange labor with one another over time. One reason that labor exchange is widespread is because it enables an efficient economy of scale for task completion. 

A common form of labor exchange is when one individual -- we'll call him `ego` -- solicits the other individuals within his social network -- his `alters` -- for help with a task at a specific point in time. Many social theorists believe that this prosocial practice is driven by **reciprocity**: if you help me today, I will help you tomorrow. 

## Perceptions and Realizations

Anthropologists who study labor exchange use a variety of techniques to document this social process. One approach is to ask every person in a community who they would recruit should they need to complete a task. This question poses a hypothetical labor exchange and the responses to can be compiled to create a *perceived* social network. 

We can think about reciprocity in a perceived network as mutual nominations. In other words, person A said they would person B, and vice versa. 

```{r, message=F, warning=F, echo=F}
library(igraph)
g1 <- graph.data.frame(rbind(c('A','B')), directed = T)
g2 <- graph.data.frame(rbind(c('A','B'),
                             c('B','A')), directed = T)
par(mfrow=c(1,2))
plot(g1, layout=layout.kamada.kawai, main="Asymmetric", 
     vertex.color='white',vertex.label.color='black', vertex.size=25, edge.color='black', edge.arrow.size=0.75)
plot(g2, layout=layout.kamada.kawai, main="Reciprocal", 
     vertex.color='white',vertex.label.color='black', vertex.size=25, edge.color='black', edge.arrow.size=0.75)
```
In abstract, we could study patterns of labor reciprocity by simulating networks of varying density that have different rates of reciprocity. This would be simple to do using the `simulate` function within `statnet`. 

```{r, warning=F, message=F}
library(statnet)
fake <- simulate(network(100, density=0.01) ~ edges + mutual, coef=c(-4,4), seed = 7)
```
```{r, echo=F, fig.cap="A synthetic network with 100 nodes and a density of 0.018. Edges color black indicate reciprocity."}
fake.ig <- intergraph::asIgraph(fake)
E(fake.ig)$mutual <- ifelse(is.mutual(fake.ig), 'black','gray80')
fake <- intergraph::asNetwork(fake.ig)
par(mar=c(0,0,0,0))
gplot(fake, edge.col = fake %e% 'mutual', vertex.col = 'cyan')
```


But in reality, not every perceived partner wgo gets nominated by someone in a survey will actually show up to help. This means that the perceived social network likely differs from the *realized* network of labor exchange. To study these networks, anthropologists use participant observation and contact diaries to keep track of who helps who.

When labor exchanges are documented using ethnography, they come closer to the realized network. This is because an anthropologist can actually join the task and observe who shows up each time. To study such a network *in silico*, we need a different generative process. Likewise, when a contact diary (i.e., work log) is used, only a subset of individuals and their exchanges are tracked. This provides a narrower albeit more realistic window into the nature of labor exchange. And like ethnography, it requires a different kind of generative model if we want to study it synthetically. 

## Starting simple 

Focusing on the ethnography approach, we desire a model that generates multiple events. Each event is "owned" by a single person, `ego`, who receive help from a pool of `N` individuals. We start by setting some parameters and sampling an `ego` at random. 

```{r}
set.seed(2)

# how many people?
N <- 6
id <- 1:N

# choose an ego 
ego <- sample(id, 1)
```

Next we need to sample a set of `alters` from the pool of individual `-ego`. How should we determine the size of the group? There may be more ethnographic reasons that determine size, but for now we will draw a number from a `binomial` distribution with a size that is equal to `N-1` and `0.5` probability. 

```{r}
# generate some alters 
alt <- sample(id[-ego], size = rbinom(1, length(id)-1, prob = 0.5))
```

Now that we have our helpers, let's cobble them together in a `data.frame`. 

```{r}
e <- expand.grid(ego, alt)
e
```

In order to build some reciprocity into the model, we need to sample a `new_ego` and check if he was in the previous group `e`. Later, we will iterate this process with a `for` loop, but for now I'll show it in steps. 

```{r}
# at the next iteration, draw another ego 
new_ego <- sample(id, 1)

# check if ego was present at the last exchange 
new_ego %in% e[,2]
```

Since `new_ego` was present at the last event, let's store the row from `e` that contains the pair, but in reverse order so that it will match the new labor group structure. 

```{r}
# if so, save the row in the reverse order 
if( (new_ego %in% e[,2]) == T ) { 
  temp <- e[ e$Var2 == new_ego, 2:1]
}
colnames(temp) <- c('Var1','Var2')
temp
```

Now we can generate another set of alters and bind our the `new_ego` row in `temp` to it at the bottom. 

```{r}
# create another set of alters and bind temp to it 
next_alt <- sample(id[-new_ego], size = rbinom(1, length(id)-1, prob = 0.5))
f <- expand.grid(new_ego, next_alt)
f <- rbind(f, temp)
f
```

If we repeat this process over and over, then we will generate a set of labor exchanges where an individual who was present at the previous event is more likely to occur in the next one, if and only if that person is the owner of the next event. In future developments of this model, we will make the reciprocity algorithm more sophisticated by searching more of the labor exchange history. 

For now, we'll embed all of this in a large function called `labor.recip`. 

```{r}
labor.recip <- function(N, layers, seed=7, p_group=0.5) {
  # set some initial parameters
  set.seed(seed=seed)
  L <- list()
  id <- 1:N
  
  # choose 1st ego
  ego <- sample(id, 1)
  
  # generate some alters 
  alt <- sample(id[-ego], size = rbinom(1, length(id)-1, prob = p_group))
  
  # expand and add event id 
  e <- expand.grid(ego, alt)
  e$eid <- 1
  L[[1]] <- e
  
  # loop through and make exchanges 
  for(k in 2:layers) {
    
    # choose new ego
    new_ego <- sample(id, 1)
    
    # check if new_ego is in previous layer 
    if( (new_ego %in% L[[k-1]][,2]) == T ) { 
      
      # paste into L
      temp <- L[[k-1]][ L[[k-1]]$Var2 == new_ego, 2:1]
      temp$eid <- k
      colnames(temp) <- c('Var1','Var2','eid')
      
      # generate another group of alters 
      new_alt <- sample(id[-new_ego], size = rbinom(1, length(id)-1, prob = p_group))
      f <- expand.grid(new_ego, new_alt)
      f$eid <- k
      f2 <- rbind( f, temp)
      L[[k]] <- f2[ !duplicated(f2), ]
    } else {
      
      # no temp object 
      new_alt <- sample(id[-new_ego], size = rbinom(1, length(id)-1, prob = p_group))
      g <- expand.grid(new_ego, new_alt)
      g$eid <- k
      L[[k]] <- g[ !duplicated(g), ]
    }
  }
  return(L)
}
```

Some things to note about this function. 

1. We store everythin in a container list `L`. 
2. We need to specify the number of time steps, which I call `layers`. 
3. We track the time steps with an event id called `eid` that is stored at each iteration. 
4. The meat of the function is in the `if` `else` statement that checks if a `new_ego` is present. This is the part of the function that will get more development.
5. It is possible to duplicate rows by chance. The `duplicated` function in `base` `R` is used to deal with this. 

Let's test it out. Our key parameters are the following:

- `N`: the number of individuals/nodes. 
- `layers`: how many time steps into the future? 
- `seed`: for reproducible examples (default = `7`). 
- `p__group`: the probability used to determine the size of the labor group. Note that if `p` is `~1`, then everyone will show up to every labor event. 

```{r}
E <- labor.recip(N=100, layers = 16, p_group = 0.1)
head(E, 3)
```

As you can see, the output is a list of data frames that contain our labor groups. These are much like the work logs we've collected in the field. We can certainly aggregate them all and then plot the aggregate network. 

```{r, message=F, warning=F, echo=F}
B <- dplyr::bind_rows(E, .id = 'eid')
library(igraph)
library(tidygraph)
library(ggraph)

g <- graph.data.frame(B[,1:3])

as_tbl_graph(g) %>%
  activate(nodes) %>%
  mutate(Degree = graph.strength(g)) %>%
  activate(edges) %>%
  ggraph() + 
  geom_edge_link0(alpha=0.3) + 
  geom_node_point(aes(size=Degree)) + 
  theme(panel.background = element_blank())
```

Next we will try a network that is much larger. 

```{r}
E <- labor.recip(N=100, layers = 200, p_group = 0.1)
```
```{r, message=F, warning=F, echo=F}
B <- dplyr::bind_rows(E, .id = 'eid')
g <- graph.data.frame(B[,1:3])

as_tbl_graph(g) %>%
  activate(nodes) %>%
  mutate(Degree = graph.strength(g)) %>%
  activate(edges) %>%
  ggraph() + 
  geom_edge_link0(alpha=0.3) + 
  geom_node_point(aes(size=Degree)) + 
  theme(panel.background = element_blank())
```

That is all for now. Next we will make this algorithm much more sophisticated and generate networks based on only a few sampling nodes. 